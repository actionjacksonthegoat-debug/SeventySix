import {
	expect,
	PAGE_TEXT,
	ROUTES,
	SELECTORS,
	test,
	TIMEOUTS
} from "@e2e-fixtures";
import { Locator, Page, Response } from "@playwright/test";

/**
 * E2E Tests for Log Management Page
 *
 * Priority: P1 (Admin Feature)
 * Tests the log management functionality including:
 * - Page structure and content
 * - Log list display
 * - Search functionality
 * - Quick filter chips
 * - Log detail dialog
 * - Refresh and pagination
 */
test.describe("Log Management Page",
	() =>
	{
		test.beforeEach(
			async ({ adminPage }: { adminPage: Page; }) =>
			{
				await adminPage.goto(ROUTES.admin.logs);
			});

		test.describe("Page Structure",
			() =>
			{
				test("should display log management heading",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const heading: Locator =
							adminPage
								.locator(SELECTORS.logManagement.pageHeader)
								.locator("h1");

						await expect(heading)
							.toHaveText(PAGE_TEXT.logManagement.title);
					});

				test("should display page subtitle",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const pageHeader: Locator =
							adminPage.locator(SELECTORS.logManagement.pageHeader);

						await expect(pageHeader)
							.toContainText(PAGE_TEXT.logManagement.subtitle);
					});

				test("should display log list component",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const logList: Locator =
							adminPage.locator(SELECTORS.logManagement.logList);

						await expect(logList)
							.toBeVisible();
					});

				test("should display data table",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const dataTable: Locator =
							adminPage.locator(SELECTORS.logManagement.dataTable);

						await expect(dataTable)
							.toBeVisible();
					});
			});

		test.describe("Data Table",
			() =>
			{
				test("should display table with header row",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const headerRow: Locator =
							adminPage.locator(SELECTORS.dataTable.headerRow);

						await expect(headerRow)
							.toBeVisible();
					});

				test("should display log data rows",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						// Logs are generated by app activity during E2E setup, so rows should exist
						const dataRows: Locator =
							adminPage.locator(SELECTORS.dataTable.dataRow);

						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						const rowCount: number =
							await dataRows.count();

						expect(rowCount)
							.toBeGreaterThan(0);
					});
			});

		test.describe("Search",
			() =>
			{
				test("should display search input",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const searchInput: Locator =
							adminPage
								.locator(SELECTORS.logManagement.dataTable)
								.locator(SELECTORS.dataTable.matInput);

						await expect(searchInput)
							.toBeVisible();
					});

				test("should filter results when searching",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						// Wait for initial data to load
						const dataRows: Locator =
							adminPage.locator(SELECTORS.dataTable.dataRow);
						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						// Search for a term unlikely to match any logs
						const searchInput: Locator =
							adminPage
								.locator(SELECTORS.logManagement.dataTable)
								.locator(SELECTORS.dataTable.matInput);
						await searchInput.fill("zzz_nonexistent_search_term");

						// Trigger search via Enter key
						await searchInput.press("Enter");

						// Should show empty state for a term that matches nothing
						const emptyState: Locator =
							adminPage.locator(SELECTORS.dataTable.emptyState);

						await expect(emptyState)
							.toBeVisible(
								{ timeout: TIMEOUTS.api });
					});
			});

		test.describe("Quick Filters",
			() =>
			{
				test("should display filter chips",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const filterChips: Locator =
							adminPage
								.locator(SELECTORS.logManagement.dataTable)
								.locator(SELECTORS.dataTable.chipOption);

						await expect(filterChips.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						const chipCount: number =
							await filterChips.count();

						// Should have All, Warnings, and Errors filters
						expect(chipCount)
							.toBeGreaterThanOrEqual(3);
					});

				test("should filter logs when clicking Warnings chip",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						// Wait for initial data
						const dataRows: Locator =
							adminPage.locator(SELECTORS.dataTable.dataRow);
						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						// Click the "Warnings" filter chip
						const warningsChip: Locator =
							adminPage
								.locator(SELECTORS.dataTable.chipOption)
								.filter(
									{ hasText: PAGE_TEXT.logManagement.chips.warnings });

						await expect(warningsChip)
							.toBeVisible();

						// Set up response listener BEFORE clicking (anti-flake pattern)
						const filterResponse: Promise<Response> =
							adminPage.waitForResponse(
								(response) =>
									response
										.url()
										.includes("/logs")
										&& response.status() === 200);

						await warningsChip.click();
						await filterResponse;

						// Results should update (either fewer rows, same rows, or empty state)
						const emptyState: Locator =
							adminPage.locator(SELECTORS.dataTable.emptyState);
						await expect(
							dataRows
								.first()
								.or(emptyState))
							.toBeVisible(
								{ timeout: TIMEOUTS.api });
					});

				test("should filter logs when clicking Errors chip",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						// Wait for initial data
						const dataRows: Locator =
							adminPage.locator(SELECTORS.dataTable.dataRow);
						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						// Click the "Errors" filter chip
						const errorsChip: Locator =
							adminPage
								.locator(SELECTORS.dataTable.chipOption)
								.filter(
									{ hasText: PAGE_TEXT.logManagement.chips.errors });

						await expect(errorsChip)
							.toBeVisible();

						// Set up response listener BEFORE clicking (anti-flake pattern)
						const filterResponse: Promise<Response> =
							adminPage.waitForResponse(
								(response) =>
									response
										.url()
										.includes("/logs")
										&& response.status() === 200);

						await errorsChip.click();
						await filterResponse;

						// Results should update
						const emptyState: Locator =
							adminPage.locator(SELECTORS.dataTable.emptyState);
						await expect(
							dataRows
								.first()
								.or(emptyState))
							.toBeVisible(
								{ timeout: TIMEOUTS.api });
					});
			});

		test.describe("Log Detail Dialog",
			() =>
			{
				/**
		 * Opens the log detail dialog by clicking the first data row
		 * and waits for the Angular component to fully render.
		 */
				async function openLogDetailDialog(adminPage: Page): Promise<Locator>
				{
					const dataRows: Locator =
						adminPage.locator(SELECTORS.dataTable.dataRow);
					await expect(dataRows.first())
						.toBeVisible(
							{ timeout: TIMEOUTS.api });

					await dataRows
						.first()
						.click();

					const dialog: Locator =
						adminPage.locator(SELECTORS.dialog.container);
					await expect(dialog)
						.toBeVisible(
							{ timeout: TIMEOUTS.api });

					// Confirm Angular component has rendered inside the dialog overlay
					await expect(dialog.locator(SELECTORS.logManagement.detailDialog))
						.toBeVisible(
							{ timeout: TIMEOUTS.api });

					return dialog;
				}

				test("should open log detail dialog when clicking a row",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const dialog: Locator =
							await openLogDetailDialog(adminPage);

						await expect(dialog.locator(SELECTORS.logManagement.detailDialog))
							.toBeVisible();
					});

				test("should display log message in detail dialog",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const dialog: Locator =
							await openLogDetailDialog(adminPage);

						const messageContent: Locator =
							dialog.locator(SELECTORS.logManagement.messageContent);

						// not.toBeEmpty() is preferred over toBeVisible() here because the
						// message-content div is always rendered (no @if guard), but may have
						// zero height when the log entry has no message text, which Playwright
						// considers not-visible even though the element is in the DOM.
						// not.toBeEmpty() correctly verifies both presence and non-empty content.
						await expect(messageContent)
							.not
							.toBeEmpty(
								{ timeout: TIMEOUTS.navigation });
						await expect(messageContent)
							.toBeVisible();
					});

				test("should close dialog when clicking close button",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						const dialog: Locator =
							await openLogDetailDialog(adminPage);

						const closeButton: Locator =
							dialog.locator(SELECTORS.dialog.closeButton);
						await closeButton.click();

						await expect(dialog)
							.toBeHidden();
					});
			});

		test.describe("Refresh",
			() =>
			{
				test("should refresh data when clicking refresh button",
					async ({ adminPage }: { adminPage: Page; }) =>
					{
						// Wait for initial data
						const dataRows: Locator =
							adminPage.locator(SELECTORS.dataTable.dataRow);
						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });

						const refreshButton: Locator =
							adminPage.locator(SELECTORS.dataTable.refreshButton);

						await expect(refreshButton)
							.toBeVisible();

						// Click refresh and verify data reloads
						const responsePromise: Promise<Response> =
							adminPage.waitForResponse(
								(response) =>
									response
										.url()
										.includes("/logs")
										&& response.status() === 200);

						await refreshButton.click();
						await responsePromise;

						// Data rows should still be visible after refresh
						await expect(dataRows.first())
							.toBeVisible(
								{ timeout: TIMEOUTS.api });
					});
			});
	});